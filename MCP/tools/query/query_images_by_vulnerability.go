package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/anchore-engine-api-server/mcp-server/config"
	"github.com/anchore-engine-api-server/mcp-server/models"
	"github.com/mark3labs/mcp-go/mcp"
)

func Query_images_by_vulnerabilityHandler(cfg *config.APIConfig) func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args, ok := request.Params.Arguments.(map[string]any)
		if !ok {
			return mcp.NewToolResultError("Invalid arguments object"), nil
		}
		queryParams := make([]string, 0)
		if val, ok := args["vulnerability_id"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("vulnerability_id=%v", val))
		}
		if val, ok := args["namespace"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("namespace=%v", val))
		}
		if val, ok := args["affected_package"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("affected_package=%v", val))
		}
		if val, ok := args["severity"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("severity=%v", val))
		}
		if val, ok := args["vendor_only"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("vendor_only=%v", val))
		}
		if val, ok := args["page"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("page=%v", val))
		}
		if val, ok := args["limit"]; ok {
			queryParams = append(queryParams, fmt.Sprintf("limit=%v", val))
		}
		queryString := ""
		if len(queryParams) > 0 {
			queryString = "?" + strings.Join(queryParams, "&")
		}
		url := fmt.Sprintf("%s/query/images/by_vulnerability%s", cfg.BaseURL, queryString)
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return mcp.NewToolResultErrorFromErr("Failed to create request", err), nil
		}
		// No authentication required for this endpoint
		req.Header.Set("Accept", "application/json")
		if val, ok := args["x-anchore-account"]; ok {
			req.Header.Set("x-anchore-account", fmt.Sprintf("%v", val))
		}

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return mcp.NewToolResultErrorFromErr("Request failed", err), nil
		}
		defer resp.Body.Close()

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return mcp.NewToolResultErrorFromErr("Failed to read response body", err), nil
		}

		if resp.StatusCode >= 400 {
			return mcp.NewToolResultError(fmt.Sprintf("API error: %s", body)), nil
		}
		// Use properly typed response
		var result models.PaginatedVulnerableImageList
		if err := json.Unmarshal(body, &result); err != nil {
			// Fallback to raw text if unmarshaling fails
			return mcp.NewToolResultText(string(body)), nil
		}

		prettyJSON, err := json.MarshalIndent(result, "", "  ")
		if err != nil {
			return mcp.NewToolResultErrorFromErr("Failed to format JSON", err), nil
		}

		return mcp.NewToolResultText(string(prettyJSON)), nil
	}
}

func CreateQuery_images_by_vulnerabilityTool(cfg *config.APIConfig) models.Tool {
	tool := mcp.NewTool("get_query_images_by_vulnerability",
		mcp.WithDescription("List images vulnerable to the specific vulnerability ID."),
		mcp.WithString("vulnerability_id", mcp.Required(), mcp.Description("The ID of the vulnerability to search for within all images stored in anchore-engine (e.g. CVE-1999-0001)")),
		mcp.WithString("namespace", mcp.Description("Filter results to images within the given vulnerability namespace (e.g. debian:8, ubuntu:14.04)")),
		mcp.WithString("affected_package", mcp.Description("Filter results to images with vulnable packages with the given package name (e.g. libssl)")),
		mcp.WithString("severity", mcp.Description("Filter results to vulnerable package/vulnerability with the given severity")),
		mcp.WithBoolean("vendor_only", mcp.Description("Filter results to include only vulnerabilities that are not marked as invalid by upstream OS vendor data")),
		mcp.WithNumber("page", mcp.Description("The page of results to fetch. Pages start at 1")),
		mcp.WithNumber("limit", mcp.Description("Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page")),
		mcp.WithString("x-anchore-account", mcp.Description("An account name to change the resource scope of the request to that account, if permissions allow (admin only)")),
	)

	return models.Tool{
		Definition: tool,
		Handler:    Query_images_by_vulnerabilityHandler(cfg),
	}
}
